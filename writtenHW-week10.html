<ol>
    <li>
        A REST API is a way of building web services that allows different applications to communicate with each other
        over the internet. It follows certain rules to make the communication efficient and standardized.

        To be "RESTful," an API needs to:

        Treat each request independently, without remembering any previous interactions.

        Separate the client (the application making the request) from the server (the application responding to the
        request).

        Use a consistent way to identify and manipulate resources, which are the things the API provides access to.

        Use standard HTTP methods like GET, POST, PUT, and DELETE to perform operations on resources.

        By following these rules, REST APIs are easier to understand, can be used by different programming languages,
        and can scale well as more users or applications start using them.
    </li>
    Node.js is a JavaScript runtime used for server-side applications. It is popular because it is efficient, scalable,
    and allows developers to use JavaScript both on the client and server sides.
    <li>
        Express.js, built on Node.js, offers key features like routing, middleware support, templating, error handling,
        and scalability. It simplifies the process of handling HTTP requests, allows for modular and reusable code,
        facilitates dynamic HTML generation, handles errors effectively, and enables the building of scalable web
        servers.
    </li>
    <li>
        In Express.js, middleware are functions that sit between the server and the routes. They can access the request
        and response objects and perform tasks like authentication, logging, and error handling. Middleware is used to
        add functionality to the application in a modular and reusable way. It is applied using the `app.use()` method
        and can be used globally or selectively for specific routes. The order of middleware execution is determined by
        their definition order.
    </li>
    <li>
        In summary, the differences between the HTTP verbs in a RESTful API are as follows:

        GET: Used to retrieve a resource or collection of resources.
        POST: Used to submit data and create a new resource.
        PUT: Used to update an entire resource.
        PATCH: Used to partially update a resource.
        DELETE: Used to delete a resource.
        GET is for retrieval, POST for creation, PUT for replacement, PATCH for partial updates, and DELETE for
        deletion.
    </li>
    <li>
        const express = require('express');
        const app = express();

        // Route with URL parameter
        app.get('/users/:id', (req, res) => {
        const userId = req.params.id;
        // Use the userId in further processing or database queries
        res.send(`User ID: ${userId}`);
        });

        // Start the server
        app.listen(3000, () => {
        console.log('Server is running on port 3000');
        });

    </li>
    <li>
        To handle errors in Express.js, you can define an error-handling middleware function with four parameters: err,
        req, res, and next. Inside the middleware, you can perform error handling logic, such as logging the error or
        sending an appropriate error response to the client. Pass the error to the next middleware using next(err). This
        triggers the error-handling middleware to be executed. This approach centralizes error handling and ensures
        consistent and controlled responses when errors occur.
    </li>
    <li>
        For CRUD operations on the "items" resource in a RESTful API with Express.js, you can structure the endpoints as
        follows:

        Create: POST /items
        Read: GET /items
        Read (specific item): GET /items/:id
        Update: PUT /items/:id
        Delete: DELETE /items/:id
        These endpoints follow RESTful conventions, where the HTTP methods correspond to the intended operation on the
        resource.
    </li>
    <li>

        To parse incoming request bodies in Express.js, use the built-in `express.json()` middleware. It automatically
        parses JSON payloads in the request body. Here's an example:


        const express = require('express');
        const app = express();

        app.use(express.json());

        app.post('/items', (req, res) => {
        const item = req.body;
        console.log(item);
        res.status(201).json({ message: 'Item created successfully' });
        });

        app.listen(3000, () => {
        console.log('Server is running on port 3000');
        });


        In this example, `express.json()` middleware is used to parse JSON payloads. The parsed JSON object can be
        accessed via `req.body`. The example demonstrates handling a POST request with a JSON payload and logging the
        item.
    </li>
    <li>
        Testing for a RESTful API built with Node and Express can be implemented using testing frameworks like Mocha,
        Jest, or Supertest. These frameworks allow you to write test cases to verify the behavior and functionality of
        your API endpoints.
        const request = require('supertest');
        const app = require('./app'); // Assuming your Express app is in a separate file named 'app.js'

        describe('API Endpoint Test', () => {
        it('should create a new item', (done) => {
        const newItem = { name: 'Example Item' };

        request(app)
        .post('/items')
        .send(newItem)
        .expect(201)
        .end((err, res) => {
        if (err) return done(err);
        // Additional assertions for the response
        // For example, check if the response body contains the created item
        expect(res.body).to.have.property('message', 'Item created successfully');
        done();
        });
        });
        });
        In the example above, we define a test case using the Mocha framework. We use the Supertest library to make an
        HTTP request to the /items endpoint with a POST method and provide a payload (newItem). We then assert that the
        response status is 201 (indicating a successful creation). Finally, we can perform additional assertions on the
        response, such as checking the response body properties.
    </li>

</ol>